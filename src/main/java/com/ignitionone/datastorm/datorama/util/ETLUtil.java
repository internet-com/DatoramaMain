package com.ignitionone.datastorm.datorama.util;

import com.ignitionone.datastorm.datorama.etl.DataType;
import com.ignitionone.datastorm.datorama.etl.DestinationTable;
import com.ignitionone.datastorm.datorama.etl.ValidationStyle;

import java.text.ParseException;
import java.util.*;

/**
 * Created by ravi.peddi on 1/3/2017.
 */
public class ETLUtil {

    public static final String DELIMITER = "\\|@\\|";

    public void verifySrcDestination(Map<String, String> mappingDoc, List<String> srcList, List<String> distList) {
        String[] srcTableColumnsNames = srcList.get(0).split(DELIMITER);
        String[] distTableColumnsNames = distList.get(0).split(DELIMITER);
        Boolean foundFlag;
        for (String srcTableColumns : srcList) {
            String[] srcTableColumnsValues = srcTableColumns.split(DELIMITER);
            foundFlag = false;
            String destTableColumnName = mappingDoc.get(srcTableColumnsValues[0]);
            if (destTableColumnName != null) {
                for (String destColumns : distList) {
                    String[] destTableColumnsValues = destColumns.split(DELIMITER);
                    if (destTableColumnsValues[0].equals(destTableColumnName)) {
                        VerifySrcDestinationValues(srcTableColumnsNames, srcTableColumnsValues, distTableColumnsNames, destTableColumnsValues);
                        foundFlag = true;
                    }
                }
                if (foundFlag == false) {
                    CommonUtil.logError("Verify destination Column :" + destTableColumnName, "Cannot find destination Column :" + destTableColumnName + " which is mapped to Source Column : " + srcTableColumnsValues[0]);
                }
            }
        }
    }

    public void VerifySrcDestinationValues(String[] srcTableColumnNames, String[] srcTableColumnsValues, String[] destTableColumnsNames, String[] destTableColumnsValues) {
        for (int i = 1; i < srcTableColumnsValues.length; i++) {
            if (srcTableColumnNames[i].toUpperCase().equals("DATA_TYPE")) {
                CommonUtil.compareTextContains(srcTableColumnsValues[i], destTableColumnsValues[i], "Verify " + srcTableColumnNames[i] + " for " + srcTableColumnsValues[0], "Verify " + srcTableColumnNames[i] + " for " + srcTableColumnsValues[0]);
            } else {
                CommonUtil.compareText(srcTableColumnsValues[i], destTableColumnsValues[i], "Verify " + srcTableColumnNames[i] + " for " + srcTableColumnsValues[0], "Verify " + srcTableColumnNames[i] + " for " + srcTableColumnsValues[0]);
            }
        }
    }


    public void verifySrcDestinationData(Map<String, DestinationTable> mapSet, List<String> srcList, List<String> destList) throws ParseException {
        Boolean foundFlag;
        String[] srcTableColumnsNames = srcList.get(0).split(DELIMITER);
        String[] distTableColumnsNames = destList.get(0).split(DELIMITER);

        List<Integer> srcKeyColumns = getKeySrcColumns(mapSet, srcTableColumnsNames);
        List<Integer> destKeyColumns = getKeyDestColumns(mapSet, distTableColumnsNames);

        List<String> modifiedSrcList = appendSrcListWithUniqueKeyColumn(srcKeyColumns, srcList);
        List<String> modifiedDestList = appendSrcListWithUniqueKeyColumn(destKeyColumns, destList);
        // List<String> modifiedDestList = appendDestListWithUniqueKeyColumn(destKeyColumns, srcList, destList);

        String[] modifiedSrcTableColumnsNames = modifiedSrcList.get(0).split(DELIMITER);
        String[] modifiedDistTableColumnsNames = modifiedDestList.get(0).split(DELIMITER);

        for (int srcCounter = 1; srcCounter < modifiedSrcList.size(); srcCounter++) {
            String[] srcValues = modifiedSrcList.get(srcCounter).split(DELIMITER);
            foundFlag = false;
            for (int destCounter = 1; destCounter < modifiedDestList.size(); destCounter++) {
                String[] destValues = modifiedDestList.get(destCounter).split(DELIMITER);
                if (srcValues[0].equals(destValues[0])) {
                    //Modified to pass in the unmodified list because we do not generate a DestinationTable for the uniquekeycolumn generated by appendSrcListWithUniqueKeyColumn,
                    //so if there were more than 2 unique columns, it would throw an error, e.g. UserUniqueGUIDCreateUtcDate has no match type
                    verifySrcDestinationDataBasedOnMapping(mapSet, srcTableColumnsNames, distTableColumnsNames, srcList.get(srcCounter).split(DELIMITER), destList.get(destCounter).split(DELIMITER));
                    foundFlag = true;

                }

            }
            if (foundFlag == false) {
                CommonUtil.logError("Verify destination data for :" + modifiedDistTableColumnsNames[0], "Cannot find destination Column Names :" + modifiedDistTableColumnsNames[0] + " having source data as : " + srcValues[0]);
            }
        }
    }

    public void verifySrcDestinationColumnData(Map<String, DestinationTable> mapSet, Map<String,String> sourceDestinationColumnNameMapping, List<String> srcList, List<String> destList) throws ParseException {
        Boolean foundFlag;
        String[] srcTableColumnsNames = srcList.get(0).split(DELIMITER);
        String[] distTableColumnsNames = destList.get(0).split(DELIMITER);

        List<Integer> srcKeyColumns = getKeySrcColumns(mapSet, srcTableColumnsNames);
        List<Integer> destKeyColumns = getKeyDestColumns(mapSet, distTableColumnsNames);

        List<String> modifiedSrcList = appendSrcListWithUniqueKeyColumn(srcKeyColumns, srcList);
        List<String> modifiedDestList = appendSrcListWithUniqueKeyColumn(destKeyColumns, destList);
        // List<String> modifiedDestList = appendDestListWithUniqueKeyColumn(destKeyColumns, srcList, destList);

        String[] modifiedSrcTableColumnsNames = modifiedSrcList.get(0).split(DELIMITER);
        String[] modifiedDistTableColumnsNames = modifiedDestList.get(0).split(DELIMITER);

        for (int srcCounter = 1; srcCounter < modifiedSrcList.size(); srcCounter++) {
            String[] srcValues = modifiedSrcList.get(srcCounter).split(DELIMITER);
            foundFlag = false;
            for (int destCounter = 1; destCounter < modifiedDestList.size(); destCounter++) {
                String[] destValues = modifiedDestList.get(destCounter).split(DELIMITER);
                if (sourceDestinationColumnNameMapping.containsKey(srcValues[0]) && sourceDestinationColumnNameMapping.get(srcValues[0]).equals(destValues[0])) {
                    //Modified to pass in the unmodified list because we do not generate a DestinationTable for the uniquekeycolumn generated by appendSrcListWithUniqueKeyColumn,
                    //so if there were more than 2 unique columns, it would throw an error, e.g. UserUniqueGUIDCreateUtcDate has no match type
                    verifySrcDestinationDataBasedOnMapping(mapSet, srcTableColumnsNames, distTableColumnsNames, srcList.get(srcCounter).split(DELIMITER), destList.get(destCounter).split(DELIMITER));
                    foundFlag = true;
                }
            }
            //added sourceDestinationColumnNameMapping.containsKey(srcValues[0]) because an mapping is expected. otherwise, no error should be thrown
            if (foundFlag == false && sourceDestinationColumnNameMapping.containsKey(srcValues[0])) {
                CommonUtil.logError("Verify destination data for :" + modifiedDistTableColumnsNames[0], "Cannot find destination Column Names :" + modifiedDistTableColumnsNames[0] + " having source data as : " + srcValues[0]);
            }
        }
    }

    private void verifySrcDestinationDataBasedOnMapping(Map<String, DestinationTable> mapSet, String[] srcTableColumnsNames, String[] destTableColumnsNames, String[] srcValues, String[] destValues) throws ParseException {

        for (int counter = 0; counter < srcTableColumnsNames.length; counter++) {
            Object srcVal = new Object();
            Object destVal = new Object();
            // if (!mapSet.get(key).getUniqueColumn()) {
            String columnUnderTest = srcTableColumnsNames[counter];
            //Check if source column exists in mapping and the  dest table
            if (mapSet.containsKey(columnUnderTest) && Arrays.asList(destTableColumnsNames).indexOf(mapSet.get(columnUnderTest).getColumnName()) >= 0){
                Integer destCounter = Arrays.asList(destTableColumnsNames).indexOf(mapSet.get(columnUnderTest).getColumnName());
                DataType dataType = mapSet.get(columnUnderTest).getDataType();
                String info = "between source  :" + columnUnderTest + " and Destination  :" + destTableColumnsNames[destCounter] + " for source column " + new String(srcValues[0]) + " and destination column " + new String(destValues[0]) ;
                boolean columnsAreNull = (srcValues[counter].toLowerCase().equals("null") || destValues[destCounter].toLowerCase().equals("null"));

                //No consideration for nulls in nonstring columns
                if(columnsAreNull && dataType != DataType.VARCHAR){
                    srcVal = srcValues[counter];
                    destVal = destValues[destCounter];
                    CommonUtil.compareText(srcVal.toString().toLowerCase(), destVal.toString().toLowerCase(), "Verify data " + info, info);
                } else if (dataType == DataType.INT) {
                    srcVal = new Integer(srcValues[counter]);
                    destVal = new Integer(destValues[destCounter]);
                    CommonUtil.compareNumberEquals((int) srcVal, (int) destVal, "Verify data " + info, info);
                } else if (dataType == DataType.DOUBLE) {
                    srcVal = new Double(srcValues[counter]);
                    destVal = new Double(destValues[destCounter]);
                    CommonUtil.compareNumberEquals((Double) srcVal, (Double) destVal, "Verify data " + info, info);
                } else if (dataType == DataType.LONG) {
                    srcVal = new Long(srcValues[counter]);
                    destVal = new Long(destValues[destCounter]);
                    CommonUtil.compareNumberEquals((long) srcVal,(long) destVal, "Verify data " + info, info);
                } else if (dataType == DataType.DATE) {
                    srcVal = srcValues[counter];
                    destVal = destValues[destCounter];
                    CommonUtil.compareDateEquals(srcVal.toString(), destVal.toString(), "Verify date " + info, info);
                } else if (dataType == DataType.VARCHAR) {
                    srcVal = srcValues[counter];
                    destVal = destValues[destCounter];
                    ValidationStyle validationStyle = mapSet.get(columnUnderTest).getValidationStyle();
                    if (validationStyle == ValidationStyle.MATCH) {
                        CommonUtil.compareText(srcVal.toString(), destVal.toString(), "Verify data " + info, info);
                    } else if (validationStyle == ValidationStyle.SUBSTRING) {
                        CommonUtil.compareTextContains(srcVal.toString(), destVal.toString(), "Verify data " + info, info);
                    }
                }
            }
        }
    }

    private void verifySrcDestinationDataBasedOnMapping1(Map<String, DestinationTable> mapSet, String[] srcTableColumnsNames, String[] distTableColumnsNames, String[] srcValues, String[] destValues) {
        int counter = 1;
        for (String key : mapSet.keySet()) {
            Object srcVal = new Object();
            Object destVal = new Object();
            // if (!mapSet.get(key).getUniqueColumn()) {
            counter = 1;
            String info = "between source Table :" + srcTableColumnsNames[counter] + " and Destination Table :" + distTableColumnsNames[counter];

            if (mapSet.get(key).getDataType().equals(DataType.INT)) {
                srcVal = new Integer(srcValues[counter]);
                destVal = new Integer(destValues[counter]);
                CommonUtil.compareNumberEquals((int) srcVal, (int) destVal, "Verify data " + info, info);
            } else if (mapSet.get(key).getDataType().equals(DataType.DOUBLE)) {
                srcVal = new Double(srcValues[counter]);
                destVal = new Double(destValues[counter]);
                CommonUtil.compareNumberEquals((Double) srcVal, (Double) destVal, "Verify data " + info, info);
            } else {
                srcVal = srcValues[counter];
                destVal = destValues[counter];
            }
            if (mapSet.get(key).getValidationStyle().equals(ValidationStyle.MATCH)) {
                CommonUtil.compareText(srcVal.toString(), destVal.toString(), "Verify data " + info, info);
            } else if (mapSet.get(key).getValidationStyle().equals(ValidationStyle.SUBSTRING)) {
                CommonUtil.compareTextContains(srcVal.toString(), destVal.toString(), "Verify data " + info, info);
            }
            // }
            counter++;
        }
    }


    private List<String> appendDestListWithUniqueKeyColumn(List<Integer> keyColumns, List<String> srcList, List<String> destList) {
        List<String> modifiedDestList = new ArrayList<>();

        for (int i = 0; i < destList.size(); i++) {
            String[] destTableColumns = destList.get(i).split(DELIMITER);
            StringBuffer sb = new StringBuffer();
            for (Integer destColumnId : keyColumns) {
                sb.append(destTableColumns[destColumnId]);
            }
            modifiedDestList.add(sb.toString() + "," + destList.get(i));
        }
        return modifiedDestList;
    }

    private List<Integer> getKeySrcColumns(Map<String, DestinationTable> mapSet, String[] tableColumnsNames) {
        List<Integer> destColumnIds = new ArrayList<>();
        Integer columnCounter = new Integer(0); // was resetting column index to 0 every iteration
        for (String tableColumnName : tableColumnsNames) {
            for (String key : mapSet.keySet()) {
                if (tableColumnName.toLowerCase().equals(key.toLowerCase()) && mapSet.get(key).getUniqueColumn()) {
                    // if (tableColumnName.toLowerCase().equals(mapSet.get(key).getColumnName().toLowerCase()) && mapSet.get(key).getUniqueColumn()) {
                    destColumnIds.add(columnCounter);
                }
            }
            columnCounter++;
        }
        return destColumnIds;
    }


    private List<Integer> getKeyDestColumns(Map<String, DestinationTable> mapSet, String[] tableColumnsNames) {
        List<Integer> destColumnIds = new ArrayList<>();
        Integer columnCounter = new Integer(0); // was resetting column index to 0 every iteration
        for (String tableColumnName : tableColumnsNames) {
            for (String key : mapSet.keySet()) {
                if (tableColumnName.toLowerCase().equals(mapSet.get(key).getColumnName().toLowerCase()) && mapSet.get(key).getUniqueColumn()) {
                    destColumnIds.add(columnCounter);
                }
            }
            columnCounter++;
        }
        return destColumnIds;
    }


    private List<String> appendSrcListWithUniqueKeyColumn(List<Integer> keyColymns, List<String> srcList) {

        List<String> modifiedSrcList = new ArrayList<>();

        for (int i = 0; i < srcList.size(); i++) {
            String[] srcTableColumns = srcList.get(i).split(DELIMITER);
            StringBuffer sb = new StringBuffer();
            for (Integer srcColumnId : keyColymns) {
                sb.append(srcTableColumns[srcColumnId]);
            }
            modifiedSrcList.add(sb.toString() + "|@|" + srcList.get(i));
        }
        return modifiedSrcList;
    }

    /*
    MapSet excel file should be in the format:
    sourceColumn,destinationTableColumnName,destinationTableUniqueColumn,destinationTableDataType,destinationTableValidationStyle
    */
    public HashMap<String, DestinationTable> getMapSet(String excelFilePath, String excelSheetName) throws Exception{
        //Get and set the map of source column to DestinationTable
        HashMap<String, DestinationTable> mapSet = new HashMap<String, DestinationTable>();
        ExcelReader excelReader = new ExcelReader();
        List<String> mapData = excelReader.getExcelAsList(excelFilePath, excelSheetName);
        //Remove column headers
        if (mapData.size() > 1){
            mapData.remove(0);
        }
        for(String row:mapData){
            String[] rowArray = row.split(DELIMITER);
            try {
                String isBooleanValue = rowArray[2].toLowerCase().trim();
                if(!isBooleanValue.equals("true") && !isBooleanValue.equals("false")){
                    throw new IllegalArgumentException();
                }
                mapSet.put(rowArray[0], new DestinationTable(rowArray[1], Boolean.valueOf(isBooleanValue), DataType.valueOf(rowArray[3].toUpperCase().trim()), ValidationStyle.valueOf(rowArray[4].toUpperCase().trim())));
            }
            catch(IllegalArgumentException iae){
                CommonUtil.logError("Incorrectly formatted mapset", "Source Column: " + rowArray[0] + "<BR> DestinationColumn: " + rowArray[1] +
                        "<BR>Uniqueness: " + rowArray[2] + "<BR> DataType: " + rowArray[3] + "<BR> ValidationStyle: " + rowArray[4]);
            }
        }
        return mapSet;
    }
}